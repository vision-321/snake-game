<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è´ªåƒè›‡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.5s ease;
            padding: 20px;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* é¡¶éƒ¨åˆ†æ•°åŒºåŸŸ */
        .score-header {
            display: flex;
            gap: 50px;
            align-items: center;
        }

        .score-item {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.2rem;
            text-align: center;
        }

        .score-item .label {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .score-item .value {
            font-weight: bold;
            font-size: 2rem;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .difficulty-easy { background: #4CAF50; color: white; }
        .difficulty-normal { background: #2196F3; color: white; }
        .difficulty-hard { background: #FF9800; color: white; }
        .difficulty-hell { background: #F44336; color: white; }

        /* æ¸¸æˆä¸»ä½“åŒºåŸŸ */
        .game-area {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        /* ä¾§è¾¹æ é€šç”¨æ ·å¼ */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 100px;
        }

        .sidebar-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
            text-align: center;
            margin-bottom: 5px;
        }

        .sidebar-btn {
            padding: 10px 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            text-align: center;
        }

        .sidebar-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
            color: white;
        }

        .sidebar-btn.active {
            background: rgba(255, 255, 255, 0.25);
            border-color: white;
            color: white;
        }

        /* æ¸¸æˆç”»å¸ƒ */
        .game-wrapper {
            position: relative;
            display: inline-block;
        }

        #gameCanvas {
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), 0 0 60px rgba(0, 0, 0, 0.3);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay h2 {
            color: white;
            font-size: 2rem;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .overlay p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .overlay .final-score {
            font-size: 3rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.7);
            margin: 20px 0;
        }

        .overlay .mobile-hint {
            display: none;
        }

        @media (max-width: 768px) {
            .overlay .desktop-hint {
                display: none;
            }
            .overlay .mobile-hint {
                display: block;
            }
        }

        /* åº•éƒ¨æ§åˆ¶åŒº */
        .bottom-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .control-btn {
            padding: 10px 20px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: white;
        }

        .music-visualizer {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 16px;
        }

        .music-visualizer .bar {
            width: 3px;
            background: white;
            border-radius: 1px;
            animation: musicBar 0.5s ease-in-out infinite;
        }

        .music-visualizer .bar:nth-child(1) { animation-delay: 0s; }
        .music-visualizer .bar:nth-child(2) { animation-delay: 0.1s; }
        .music-visualizer .bar:nth-child(3) { animation-delay: 0.2s; }
        .music-visualizer .bar:nth-child(4) { animation-delay: 0.3s; }

        @keyframes musicBar {
            0%, 100% { height: 4px; }
            50% { height: 14px; }
        }

        .music-visualizer.paused .bar {
            animation: none;
            height: 4px;
        }

        /* æ“ä½œè¯´æ˜ */
        .instructions {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            text-align: center;
        }

        .instructions kbd {
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.12);
            border-radius: 4px;
            margin: 0 2px;
        }

        /* è™šæ‹Ÿæ–¹å‘é”® */
        .virtual-controls {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
        }

        .virtual-controls .row {
            display: flex;
            gap: 5px;
        }

        .virtual-btn {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: all 0.15s ease;
        }

        .virtual-btn:active {
            background: rgba(255, 255, 255, 0.35);
            transform: scale(0.95);
        }

        .virtual-btn.placeholder {
            visibility: hidden;
        }

        /* ç§»åŠ¨ç«¯å“åº”å¼å¸ƒå±€ */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .main-container {
                gap: 15px;
            }

            .score-header {
                gap: 20px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .score-item .value {
                font-size: 1.5rem;
            }

            .game-area {
                flex-direction: column;
                gap: 15px;
            }

            .sidebar {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                min-width: auto;
            }

            .sidebar-title {
                width: 100%;
            }

            .sidebar-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            #gameCanvas {
                max-width: 100%;
                height: auto;
            }

            .bottom-controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            .control-btn {
                padding: 8px 15px;
                font-size: 0.85rem;
            }

            .instructions {
                display: none;
            }

            .virtual-controls {
                display: flex;
            }

            .overlay h2 {
                font-size: 1.5rem;
            }

            .overlay p {
                font-size: 0.95rem;
            }

            .overlay .final-score {
                font-size: 2.5rem;
            }
        }

        @media (max-width: 520px) {
            #gameCanvas {
                width: 100%;
                max-width: 350px;
            }

            .virtual-btn {
                width: 55px;
                height: 55px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- é¡¶éƒ¨åˆ†æ•°åŒºåŸŸ -->
        <div class="score-header">
            <div class="score-item">
                <div class="label">å½“å‰åˆ†æ•°</div>
                <div class="value" id="score">0</div>
            </div>
            <div class="score-item">
                <div class="label">éš¾åº¦</div>
                <div id="difficultyBadge" class="difficulty-badge difficulty-normal">æ™®é€š</div>
            </div>
            <div class="score-item">
                <div class="label">æœ€é«˜åˆ†</div>
                <div class="value" id="highScore">0</div>
            </div>
        </div>

        <!-- æ¸¸æˆä¸»ä½“åŒºåŸŸ -->
        <div class="game-area">
            <!-- å·¦ä¾§ï¼šéš¾åº¦é€‰æ‹© -->
            <div class="sidebar">
                <div class="sidebar-title">éš¾åº¦é€‰æ‹©</div>
                <button class="sidebar-btn" data-difficulty="easy">ğŸŸ¢ ç®€å•</button>
                <button class="sidebar-btn active" data-difficulty="normal">ğŸ”µ æ™®é€š</button>
                <button class="sidebar-btn" data-difficulty="hard">ğŸŸ  å›°éš¾</button>
                <button class="sidebar-btn" data-difficulty="hell">ğŸ”´ åœ°ç‹±</button>
            </div>

            <!-- æ¸¸æˆç”»å¸ƒ -->
            <div class="game-wrapper">
                <canvas id="gameCanvas" width="500" height="500"></canvas>
                <div class="overlay" id="startOverlay">
                    <h2>ğŸ è´ªåƒè›‡</h2>
                    <p class="desktop-hint">æŒ‰ <kbd>ç©ºæ ¼</kbd> å¼€å§‹æ¸¸æˆ</p>
                    <p class="mobile-hint">ç‚¹å‡»å±å¹•å¼€å§‹æ¸¸æˆ</p>
                </div>
                <div class="overlay hidden" id="pauseOverlay">
                    <h2>â¸ï¸ æš‚åœ</h2>
                    <p class="desktop-hint">æŒ‰ <kbd>ç©ºæ ¼</kbd> ç»§ç»­</p>
                    <p class="mobile-hint">ç‚¹å‡»å±å¹•ç»§ç»­</p>
                </div>
                <div class="overlay hidden" id="gameOverOverlay">
                    <h2>ğŸ’€ æ¸¸æˆç»“æŸ</h2>
                    <div class="final-score" id="finalScore">0</div>
                    <p class="desktop-hint">æŒ‰ <kbd>ç©ºæ ¼</kbd> æˆ– <kbd>R</kbd> é‡æ–°å¼€å§‹</p>
                    <p class="mobile-hint">ç‚¹å‡»å±å¹•é‡æ–°å¼€å§‹</p>
                </div>
            </div>

            <!-- å³ä¾§ï¼šçš®è‚¤é€‰æ‹© -->
            <div class="sidebar">
                <div class="sidebar-title">ä¸»é¢˜çš®è‚¤</div>
                <button class="sidebar-btn active" data-skin="classic">ğŸŸ¢ ç»å…¸ç»¿</button>
                <button class="sidebar-btn" data-skin="neon">ğŸ”µ éœ“è™¹è“</button>
                <button class="sidebar-btn" data-skin="flame">ğŸ”´ çƒˆç„°çº¢</button>
                <button class="sidebar-btn" data-skin="night">ğŸŸ£ æš—å¤œç´«</button>
            </div>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶åŒº -->
        <div class="bottom-controls">
            <button class="control-btn active" id="soundBtn">ğŸ”Š éŸ³æ•ˆ</button>
            <button class="control-btn" id="musicBtn">
                ğŸµ èƒŒæ™¯éŸ³ä¹
                <span class="music-visualizer paused" id="musicVisualizer">
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                    <span class="bar"></span>
                </span>
            </button>
        </div>

        <!-- æ“ä½œè¯´æ˜ -->
        <div class="instructions">
            <kbd>â†‘</kbd><kbd>â†“</kbd><kbd>â†</kbd><kbd>â†’</kbd> æˆ– <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> ç§»åŠ¨ ï½œ
            <kbd>ç©ºæ ¼</kbd> å¼€å§‹/æš‚åœ ï½œ <kbd>R</kbd> é‡æ–°å¼€å§‹ ï½œ <kbd>M</kbd> éŸ³ä¹å¼€å…³
        </div>

        <!-- è™šæ‹Ÿæ–¹å‘é”®ï¼ˆç§»åŠ¨ç«¯æ˜¾ç¤ºï¼‰ -->
        <div class="virtual-controls" id="virtualControls">
            <div class="row">
                <button class="virtual-btn placeholder"></button>
                <button class="virtual-btn" data-direction="up">â†‘</button>
                <button class="virtual-btn placeholder"></button>
            </div>
            <div class="row">
                <button class="virtual-btn" data-direction="left">â†</button>
                <button class="virtual-btn" data-direction="down">â†“</button>
                <button class="virtual-btn" data-direction="right">â†’</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== æ¸¸æˆé…ç½® ====================
        const GRID_SIZE = 20;
        const CANVAS_SIZE = 500;
        const CELL_COUNT = CANVAS_SIZE / GRID_SIZE;

        // éš¾åº¦é…ç½®
        const difficulties = {
            easy:   { name: 'ç®€å•', baseSpeed: 200, minSpeed: 100, speedStep: 5,  scorePerFood: 5,  class: 'difficulty-easy' },
            normal: { name: 'æ™®é€š', baseSpeed: 150, minSpeed: 70,  speedStep: 10, scorePerFood: 10, class: 'difficulty-normal' },
            hard:   { name: 'å›°éš¾', baseSpeed: 100, minSpeed: 50,  speedStep: 15, scorePerFood: 15, class: 'difficulty-hard' },
            hell:   { name: 'åœ°ç‹±', baseSpeed: 70,  minSpeed: 30,  speedStep: 20, scorePerFood: 20, class: 'difficulty-hell' }
        };

        // çš®è‚¤é…ç½®
        const skins = {
            classic: {
                name: 'ç»å…¸ç»¿',
                snake: ['#4CAF50', '#2E7D32'],
                food: '#FF5722',
                foodGlow: 'rgba(255, 87, 34, 0.6)',
                bg: '#1a1a2e',
                grid: 'rgba(255, 255, 255, 0.05)'
            },
            neon: {
                name: 'éœ“è™¹è“',
                snake: ['#00BCD4', '#006064'],
                food: '#03A9F4',
                foodGlow: 'rgba(3, 169, 244, 0.6)',
                bg: '#0a1628',
                grid: 'rgba(0, 188, 212, 0.1)'
            },
            flame: {
                name: 'çƒˆç„°çº¢',
                snake: ['#FF5722', '#BF360C'],
                food: '#FFC107',
                foodGlow: 'rgba(255, 193, 7, 0.6)',
                bg: '#2d1810',
                grid: 'rgba(255, 87, 34, 0.1)'
            },
            night: {
                name: 'æš—å¤œç´«',
                snake: ['#9C27B0', '#4A148C'],
                food: '#E91E63',
                foodGlow: 'rgba(233, 30, 99, 0.6)',
                bg: '#1a0a2e',
                grid: 'rgba(156, 39, 176, 0.1)'
            }
        };

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let snake = [];
        let direction = 'right';
        let nextDirection = 'right';
        let food = { x: 0, y: 0 };
        let score = 0;
        let highScore = parseInt(localStorage.getItem('snakeHighScore')) || 0;
        let gameState = 'waiting';
        let speed = 150;
        let gameLoop = null;
        let currentSkin = localStorage.getItem('snakeSkin') || 'classic';
        let currentDifficulty = localStorage.getItem('snakeDifficulty') || 'normal';
        let soundEnabled = localStorage.getItem('snakeSound') !== 'false';
        let musicEnabled = false;

        // ==================== DOM å…ƒç´  ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const finalScoreEl = document.getElementById('finalScore');
        const startOverlay = document.getElementById('startOverlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const soundBtn = document.getElementById('soundBtn');
        const musicBtn = document.getElementById('musicBtn');
        const musicVisualizer = document.getElementById('musicVisualizer');
        const difficultyBadge = document.getElementById('difficultyBadge');
        const difficultyBtns = document.querySelectorAll('[data-difficulty]');
        const skinBtns = document.querySelectorAll('[data-skin]');

        // ==================== éŸ³æ•ˆç³»ç»Ÿ ====================
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playEatSound() {
            if (!soundEnabled || !audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.setValueAtTime(587.33, audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(880, audioCtx.currentTime + 0.1);

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playGameOverSound() {
            if (!soundEnabled || !audioCtx) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.setValueAtTime(392, audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(349.23, audioCtx.currentTime + 0.15);
            oscillator.frequency.setValueAtTime(293.66, audioCtx.currentTime + 0.3);

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.5);
        }

        // ==================== 8-bit èƒŒæ™¯éŸ³ä¹ ====================
        const bgmMelody = [
            { note: 'E5', duration: 0.15 },
            { note: 'E5', duration: 0.15 },
            { note: 'E5', duration: 0.15 },
            { note: 'C5', duration: 0.15 },
            { note: 'E5', duration: 0.3 },
            { note: 'G5', duration: 0.3 },
            { note: 'G4', duration: 0.3 },
            { note: 'C5', duration: 0.3 },
            { note: 'G4', duration: 0.15 },
            { note: 'E4', duration: 0.3 },
            { note: 'A4', duration: 0.2 },
            { note: 'B4', duration: 0.2 },
            { note: 'Bb4', duration: 0.15 },
            { note: 'A4', duration: 0.3 },
            { note: 'G4', duration: 0.2 },
            { note: 'E5', duration: 0.2 },
            { note: 'G5', duration: 0.2 },
            { note: 'A5', duration: 0.3 },
            { note: 'F5', duration: 0.15 },
            { note: 'G5', duration: 0.15 },
            { note: 'E5', duration: 0.3 },
            { note: 'C5', duration: 0.15 },
            { note: 'D5', duration: 0.15 },
            { note: 'B4', duration: 0.3 },
        ];

        const bgmBass = [
            { note: 'C3', duration: 0.3 },
            { note: 'G3', duration: 0.3 },
            { note: 'C3', duration: 0.3 },
            { note: 'G3', duration: 0.3 },
            { note: 'F3', duration: 0.3 },
            { note: 'C3', duration: 0.3 },
            { note: 'G3', duration: 0.3 },
            { note: 'C3', duration: 0.3 },
        ];

        const noteFrequencies = {
            'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'Bb4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        };

        let melodyIndex = 0;
        let bassIndex = 0;
        let melodyTimeout = null;
        let bassTimeout = null;

        function playNote(frequency, duration, type = 'square', volume = 0.15) {
            if (!audioCtx || !musicEnabled) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);

            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration * 0.9);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playMelody() {
            if (!musicEnabled || gameState !== 'playing') return;

            const note = bgmMelody[melodyIndex];
            const freq = noteFrequencies[note.note];
            if (freq) {
                playNote(freq, note.duration, 'square', 0.12);
            }

            melodyIndex = (melodyIndex + 1) % bgmMelody.length;
            melodyTimeout = setTimeout(playMelody, note.duration * 1000);
        }

        function playBass() {
            if (!musicEnabled || gameState !== 'playing') return;

            const note = bgmBass[bassIndex];
            const freq = noteFrequencies[note.note];
            if (freq) {
                playNote(freq, note.duration, 'triangle', 0.1);
            }

            bassIndex = (bassIndex + 1) % bgmBass.length;
            bassTimeout = setTimeout(playBass, note.duration * 1000);
        }

        function startBGM() {
            if (!musicEnabled) return;
            initAudio();

            melodyIndex = 0;
            bassIndex = 0;

            playMelody();
            playBass();

            musicVisualizer.classList.remove('paused');
        }

        function stopBGM() {
            clearTimeout(melodyTimeout);
            clearTimeout(bassTimeout);
            musicVisualizer.classList.add('paused');
        }

        function toggleMusic() {
            initAudio();
            musicEnabled = !musicEnabled;

            if (musicEnabled) {
                musicBtn.classList.add('active');
                if (gameState === 'playing') {
                    startBGM();
                }
            } else {
                musicBtn.classList.remove('active');
                stopBGM();
            }
        }

        // ==================== æ¸¸æˆé€»è¾‘ ====================
        function initGame() {
            const diff = difficulties[currentDifficulty];

            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            speed = diff.baseSpeed;
            updateScore();
            updateDifficultyBadge();
            generateFood();
        }

        function updateDifficultyBadge() {
            const diff = difficulties[currentDifficulty];
            difficultyBadge.textContent = diff.name;
            difficultyBadge.className = 'difficulty-badge ' + diff.class;
        }

        function generateFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * CELL_COUNT),
                    y: Math.floor(Math.random() * CELL_COUNT)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
            food = newFood;
        }

        function moveSnake() {
            direction = nextDirection;

            const head = { ...snake[0] };

            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            if (head.x < 0 || head.x >= CELL_COUNT || head.y < 0 || head.y >= CELL_COUNT) {
                gameOver();
                return;
            }

            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                const diff = difficulties[currentDifficulty];
                score += diff.scorePerFood;
                updateScore();
                generateFood();
                playEatSound();

                if (speed > diff.minSpeed) {
                    speed = Math.max(diff.minSpeed, diff.baseSpeed - Math.floor(score / 50) * diff.speedStep);
                }
            } else {
                snake.pop();
            }
        }

        function updateScore() {
            scoreEl.textContent = score;
            if (score > highScore) {
                highScore = score;
                highScoreEl.textContent = highScore;
                localStorage.setItem('snakeHighScore', highScore);
            }
        }

        function gameOver() {
            gameState = 'over';
            clearTimeout(gameLoop);
            stopBGM();
            finalScoreEl.textContent = score;
            gameOverOverlay.classList.remove('hidden');
            playGameOverSound();
        }

        function startGame() {
            initAudio();
            initGame();
            gameState = 'playing';
            startOverlay.classList.add('hidden');
            gameOverOverlay.classList.add('hidden');
            pauseOverlay.classList.add('hidden');

            if (musicEnabled) {
                startBGM();
            }

            runGameLoop();
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                clearTimeout(gameLoop);
                stopBGM();
                pauseOverlay.classList.remove('hidden');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseOverlay.classList.add('hidden');
                if (musicEnabled) {
                    startBGM();
                }
                runGameLoop();
            }
        }

        function runGameLoop() {
            if (gameState !== 'playing') return;

            moveSnake();
            render();

            gameLoop = setTimeout(runGameLoop, speed);
        }

        // ==================== æ¸²æŸ“ ====================
        function render() {
            const skin = skins[currentSkin];

            ctx.fillStyle = skin.bg;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            ctx.strokeStyle = skin.grid;
            ctx.lineWidth = 1;
            for (let i = 0; i <= CELL_COUNT; i++) {
                ctx.beginPath();
                ctx.moveTo(i * GRID_SIZE, 0);
                ctx.lineTo(i * GRID_SIZE, CANVAS_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * GRID_SIZE);
                ctx.lineTo(CANVAS_SIZE, i * GRID_SIZE);
                ctx.stroke();
            }

            ctx.shadowColor = skin.foodGlow;
            ctx.shadowBlur = 15;
            ctx.fillStyle = skin.food;
            ctx.beginPath();
            ctx.arc(
                food.x * GRID_SIZE + GRID_SIZE / 2,
                food.y * GRID_SIZE + GRID_SIZE / 2,
                GRID_SIZE / 2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            ctx.shadowBlur = 0;

            snake.forEach((segment, index) => {
                const ratio = index / snake.length;
                const color = lerpColor(skin.snake[0], skin.snake[1], ratio);

                ctx.fillStyle = color;

                const radius = index === 0 ? 8 : 4;
                roundRect(
                    ctx,
                    segment.x * GRID_SIZE + 1,
                    segment.y * GRID_SIZE + 1,
                    GRID_SIZE - 2,
                    GRID_SIZE - 2,
                    radius
                );

                if (index === 0) {
                    ctx.fillStyle = 'white';
                    const eyeOffset = GRID_SIZE / 4;
                    let eyeX1, eyeY1, eyeX2, eyeY2;

                    switch (direction) {
                        case 'up':
                            eyeX1 = segment.x * GRID_SIZE + eyeOffset;
                            eyeY1 = segment.y * GRID_SIZE + eyeOffset;
                            eyeX2 = segment.x * GRID_SIZE + GRID_SIZE - eyeOffset;
                            eyeY2 = segment.y * GRID_SIZE + eyeOffset;
                            break;
                        case 'down':
                            eyeX1 = segment.x * GRID_SIZE + eyeOffset;
                            eyeY1 = segment.y * GRID_SIZE + GRID_SIZE - eyeOffset;
                            eyeX2 = segment.x * GRID_SIZE + GRID_SIZE - eyeOffset;
                            eyeY2 = segment.y * GRID_SIZE + GRID_SIZE - eyeOffset;
                            break;
                        case 'left':
                            eyeX1 = segment.x * GRID_SIZE + eyeOffset;
                            eyeY1 = segment.y * GRID_SIZE + eyeOffset;
                            eyeX2 = segment.x * GRID_SIZE + eyeOffset;
                            eyeY2 = segment.y * GRID_SIZE + GRID_SIZE - eyeOffset;
                            break;
                        case 'right':
                            eyeX1 = segment.x * GRID_SIZE + GRID_SIZE - eyeOffset;
                            eyeY1 = segment.y * GRID_SIZE + eyeOffset;
                            eyeX2 = segment.x * GRID_SIZE + GRID_SIZE - eyeOffset;
                            eyeY2 = segment.y * GRID_SIZE + GRID_SIZE - eyeOffset;
                            break;
                    }

                    ctx.beginPath();
                    ctx.arc(eyeX1, eyeY1, 3, 0, Math.PI * 2);
                    ctx.arc(eyeX2, eyeY2, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        function lerpColor(color1, color2, ratio) {
            const hex = (c) => parseInt(c.slice(1), 16);
            const r = (h) => (h >> 16) & 255;
            const g = (h) => (h >> 8) & 255;
            const b = (h) => h & 255;

            const h1 = hex(color1);
            const h2 = hex(color2);

            const nr = Math.round(r(h1) + (r(h2) - r(h1)) * ratio);
            const ng = Math.round(g(h1) + (g(h2) - g(h1)) * ratio);
            const nb = Math.round(b(h1) + (b(h2) - b(h1)) * ratio);

            return `rgb(${nr}, ${ng}, ${nb})`;
        }

        function applySkin(skinName) {
            currentSkin = skinName;
            document.body.style.backgroundColor = skins[skinName].bg;
            localStorage.setItem('snakeSkin', skinName);

            skinBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.skin === skinName);
            });

            render();
        }

        function applyDifficulty(diffName) {
            currentDifficulty = diffName;
            localStorage.setItem('snakeDifficulty', diffName);
            updateDifficultyBadge();

            difficultyBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.difficulty === diffName);
            });

            if (gameState === 'waiting') {
                initGame();
                render();
            }
        }

        // ==================== äº‹ä»¶ç›‘å¬ ====================

        // è§¦æ‘¸æ»‘åŠ¨æ§åˆ¶ï¼ˆä¼˜åŒ–ï¼šä½¿ç”¨ touchmove å®æ—¶æ£€æµ‹ï¼Œæé«˜å“åº”é€Ÿåº¦ï¼‰
        let touchStartX = 0;
        let touchStartY = 0;
        let touchHandled = false;  // æ ‡è®°æœ¬æ¬¡è§¦æ‘¸æ˜¯å¦å·²å¤„ç†æ–¹å‘
        const MIN_SWIPE_DISTANCE = 20;  // é™ä½é˜ˆå€¼ï¼Œæ›´å¿«å“åº”

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchHandled = false;  // é‡ç½®æ ‡è®°
            e.preventDefault();
        }, { passive: false });

        // ä½¿ç”¨ touchmove å®æ—¶æ£€æµ‹æ–¹å‘å˜åŒ–ï¼Œä¸éœ€è¦ç­‰å¾…æ‰‹æŒ‡æŠ¬èµ·
        canvas.addEventListener('touchmove', (e) => {
            if (gameState !== 'playing' || touchHandled) return;

            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;

            // è¾¾åˆ°æœ€å°æ»‘åŠ¨è·ç¦»æ‰è§¦å‘
            if (Math.abs(deltaX) < MIN_SWIPE_DISTANCE && Math.abs(deltaY) < MIN_SWIPE_DISTANCE) {
                return;
            }

            const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };
            let newDir;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                newDir = deltaX > 0 ? 'right' : 'left';
            } else {
                newDir = deltaY > 0 ? 'down' : 'up';
            }

            if (opposites[newDir] !== direction) {
                nextDirection = newDir;
                touchHandled = true;  // æ ‡è®°å·²å¤„ç†ï¼Œé¿å…è¿ç»­è§¦å‘
                // æ›´æ–°èµ·ç‚¹ï¼Œå…è®¸è¿ç»­æ»‘åŠ¨æ”¹å˜æ–¹å‘
                touchStartX = touchX;
                touchStartY = touchY;
                // çŸ­æš‚å»¶è¿Ÿåé‡ç½®ï¼Œå…è®¸ç»§ç»­æ»‘åŠ¨
                setTimeout(() => { touchHandled = false; }, 100);
            }

            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (gameState !== 'playing') {
                // ç‚¹å‡»ç”»å¸ƒå¼€å§‹/æš‚åœæ¸¸æˆ
                if (gameState === 'waiting' || gameState === 'over') {
                    startGame();
                } else if (gameState === 'paused') {
                    togglePause();
                }
                return;
            }

            // å¦‚æœæ²¡æœ‰å¤„ç†è¿‡æ»‘åŠ¨ï¼Œåˆ™è§†ä¸ºç‚¹å‡»æš‚åœ
            if (!touchHandled) {
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                if (Math.abs(deltaX) < MIN_SWIPE_DISTANCE && Math.abs(deltaY) < MIN_SWIPE_DISTANCE) {
                    togglePause();
                }
            }
        }, { passive: false });

        // Overlay è§¦æ‘¸/ç‚¹å‡»äº‹ä»¶ï¼ˆè§£å†³ overlay é˜»æŒ¡ canvas è§¦æ‘¸äº‹ä»¶çš„é—®é¢˜ï¼‰
        const overlays = [startOverlay, pauseOverlay, gameOverOverlay];
        overlays.forEach(overlay => {
            // è§¦æ‘¸äº‹ä»¶
            overlay.addEventListener('touchend', (e) => {
                e.preventDefault();
                initAudio();
                if (gameState === 'waiting' || gameState === 'over') {
                    startGame();
                } else if (gameState === 'paused') {
                    togglePause();
                }
            }, { passive: false });

            // ç‚¹å‡»äº‹ä»¶ï¼ˆå…¼å®¹æ¡Œé¢ç«¯æµ‹è¯•ï¼‰
            overlay.addEventListener('click', (e) => {
                initAudio();
                if (gameState === 'waiting' || gameState === 'over') {
                    startGame();
                } else if (gameState === 'paused') {
                    togglePause();
                }
            });
        });

        // è™šæ‹Ÿæ–¹å‘é”®æ§åˆ¶
        const virtualBtns = document.querySelectorAll('.virtual-btn[data-direction]');
        virtualBtns.forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                initAudio();

                if (gameState !== 'playing') {
                    if (gameState === 'waiting' || gameState === 'over') {
                        startGame();
                    }
                    return;
                }

                const newDir = btn.dataset.direction;
                const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };

                if (opposites[newDir] !== direction) {
                    nextDirection = newDir;
                }
            }, { passive: false });

            // åŒæ—¶æ”¯æŒé¼ æ ‡ç‚¹å‡»ï¼ˆæ–¹ä¾¿æµ‹è¯•ï¼‰
            btn.addEventListener('click', () => {
                initAudio();

                if (gameState !== 'playing') {
                    if (gameState === 'waiting' || gameState === 'over') {
                        startGame();
                    }
                    return;
                }

                const newDir = btn.dataset.direction;
                const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };

                if (opposites[newDir] !== direction) {
                    nextDirection = newDir;
                }
            });
        });

        document.addEventListener('keydown', (e) => {
            const keyMap = {
                'ArrowUp': 'up', 'KeyW': 'up',
                'ArrowDown': 'down', 'KeyS': 'down',
                'ArrowLeft': 'left', 'KeyA': 'left',
                'ArrowRight': 'right', 'KeyD': 'right'
            };

            if (keyMap[e.code] && gameState === 'playing') {
                const newDir = keyMap[e.code];
                const opposites = { up: 'down', down: 'up', left: 'right', right: 'left' };

                if (opposites[newDir] !== direction) {
                    nextDirection = newDir;
                }
                e.preventDefault();
            }

            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'waiting' || gameState === 'over') {
                    startGame();
                } else {
                    togglePause();
                }
            }

            if (e.code === 'KeyR' && (gameState === 'over' || gameState === 'playing' || gameState === 'paused')) {
                startGame();
            }

            if (e.code === 'KeyM') {
                toggleMusic();
            }
        });

        soundBtn.addEventListener('click', () => {
            initAudio();
            soundEnabled = !soundEnabled;
            soundBtn.textContent = soundEnabled ? 'ğŸ”Š éŸ³æ•ˆ' : 'ğŸ”‡ é™éŸ³';
            soundBtn.classList.toggle('active', soundEnabled);
            localStorage.setItem('snakeSound', soundEnabled);
        });

        musicBtn.addEventListener('click', toggleMusic);

        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                applyDifficulty(btn.dataset.difficulty);
            });
        });

        skinBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                applySkin(btn.dataset.skin);
            });
        });

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            highScoreEl.textContent = highScore;
            soundBtn.textContent = soundEnabled ? 'ğŸ”Š éŸ³æ•ˆ' : 'ğŸ”‡ é™éŸ³';
            soundBtn.classList.toggle('active', soundEnabled);

            applySkin(currentSkin);
            applyDifficulty(currentDifficulty);

            initGame();
            render();
        }

        init();
    </script>
</body>
</html>
